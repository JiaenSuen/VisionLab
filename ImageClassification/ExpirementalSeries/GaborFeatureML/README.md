# Feature Extraction with Gabor filters & ML Image Classification
## Feature Extraction
### Gabor Feature Filtering
The Gabor filter, named after Dennis Gabor, was originally a signal processing and analysis method. Later, Gösta Granlund extended it to two dimensions by adding a reference orientation, and it is used for image processing applications such as texture analysis and mid-level feature extraction. Compared with the edge detection and corner detection mentioned earlier, Gabor extracts more complex patterns, such as texture, local shape or directional features.

![image](Graph/GaborMath.png)

A Gabor filter is a convolutional filter that combines a Gaussian function element with a sine wave. The Gaussian function provides locality and weights, while the sine wave term provides directionality and frequency characteristics. Originally, the sine term was written as $exp(i(2πfx′+ϕ))$, but in practical applications, we often only take the real part, i.e., the cosine term, for filtering. Therefore, the sine function is also written as $cos(2πfx′+ϕ)$ elsewhere. The input parameters g(x, y) are the image pixel coordinates, $\lambda$ represents the wavelength of the sine component, $\theta$ controls the direction, $\psi$ is the phase offset that controls the starting point of the waveform and controls symmetry and response direction, the standard deviation of the Gaussian function represents the receptive field size, and γ is the aspect ratio used to control the elliptical shape generated by the Gaussian function. After substituting all the parameters, the Gabor value is calculated for each (x, y) until the matrix values ​​are filled, thus generating a kernel. Therefore, it can be seen that there are many parameters to control what the filter is like, which can generate a large number of filter combinations.

### Sobel Edge Detection

The Sobel filter is a discrete difference operator commonly used in image processing and computer vision, primarily for edge detection. It highlights frequently changing edge regions by calculating the gradient approximation of the image's brightness function and convolving the image with horizontal and vertical kernels (masks).



## Result
### Light GBM 
from :  *LightGBM: A Highly Efficient Gradient Boosting
Decision Tree*  
install : https://pypi.org/project/lightgbm/


![image](Result/lgb/lgb_cm_report.png)

### XGBoost 
from :  *XGBoost: A Scalable Tree Boosting System*  
install : https://pypi.org/project/xgboost/

![image](Result/xgb/xgb_cm_report.png)


### Random Forest
![image](Result/rf/rf_cm_report.png)
